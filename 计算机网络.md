### 1. HTTP 常用的请求方式，区别和用途？

- **GET**: 发送请求，获取服务器数据
- **POST**：向URL指定的资源提交数据
- **PUT**：向服务器提交数据，以修改数据
- **HEAD**:请求页面的首部，获取资源的元信息
- **DELETE**：删除服务器上的某些资源
- **CONNECT**：建立连接隧道，用于代理服务器
- **OPTIONS**：列出可对资源实行的请求方法，常用于跨域
- **TRACE**：追踪请求-响应的传输路径

### 2. HTTP 常用的状态码及含义？

- 1xx：接受的请求正在处理 （信息性状态码）
- 2xx：表示请求正常处理完毕 （成功状态码）
- 3xx：表示重定向状态，需要重新请求 （重定向状态码）
- 4xx：服务器无法处理请求 （客户端错误状态码）
- 5xx：服务器处理请求出错 （服务端错误状态码）

**常用状态码如下：**

- 101 切换请求协议，从 HTTP 切换到 WebSocket
- 200 请求成功，表示正常返回信息。
- 301 永久重定向，会缓存
- 302 临时重定向，不会缓存
- 400 请求错误
- 403 服务器禁止访问
- 404 找不到与 URI相匹配的资源。
- 500 常见的服务器端错误

### 3. 从浏览器地址栏输入url到显示主页的过程

1. DNS解析，查找真正的ip地址
2. 与服务器建立TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

<img src="images/8e53adb5506c4974813b5d3c72e7c71etplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="70%" />

### 4. 如何理解HTTP协议是无状态的

每次HTTP请求都是独立的，无相关的，默认不需要保存上下文信息的。我们来看个便于理解的例子：

**有状态：**

- A：今天吃啥子？
- B：罗非鱼！
- A：味道怎么样呀？
- B：还不错，好香。

**无状态：**

- A：今天吃啥子？
- B：罗非鱼！
- A：味道怎么样呀？
- B：？啊？啥？什么鬼？什么味道怎么样？

**加下cookie这玩意**：

- A：今天吃啥子？
- B：罗非鱼
- A：你今天吃的罗非鱼味道怎么样呀？
- B：还不错，好香。

### 5. HTTP 1.0，1.1，2.0 的版本区别

**HTTP 1.0**

- HTTP 1.0规定浏览器与服务器只保持**短暂的连接**，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。它也可以强制开启长链接，例如设置`Connection: keep-alive` 这个字段

**HTTP 1.1**

- 引入了长连接，即**TCP连接默认不关闭，可以被多个请求复用**。
- 引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。
- 缓存处理，引入了更多的缓存控制策略，如`Cache-Control`、`Etag/If-None-Match`等。
- 错误状态管理，新增了24个错误状态响应码，如409表示请求的资源与资源的当前状态发生冲突。

**HTTP 2**

- 采用了**多路复用**，即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
- 服务端推送，HTTP 2允许服务器未经请求，主动向客户端发送资源

### 6. 说下计算机网络体系结构

计算机网路体系结构主要有ISO七层模型、TCP/IP 四层模型、五层体系结构

<img src="images/09faa09e45c24062850ff666696fdc9atplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="计算机网络体系结构" width="50%" />

**ISO七层模型**

ISO七层模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。

- 应用层：网络服务与最终用户的一个接口，协议有：**HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP**
- 表示层：数据的表示、安全、压缩。
- 会话层：建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话
- 传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：**TCP UDP，数据包一旦离开网卡即进入网络传输层**
- 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：**ICMP IGMP IP（IPV4 IPV6）**
- 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。
- 物理层：建立、维护、断开物理连接。

**TCP/IP 四层模型**

- 应用层：对应于OSI参考模型的（应用层、表示层、会话层），为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等
- 传输层:对应OSI的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。定义了TCP和UDP两层协议。
- 网际层：对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）
- 网络接口层：与OSI参考模型的数据链路层、物理层对应。它负责监视数据在主机和网络之间的交换。

**五层体系结构**

- 应用层：通过应用进程间的交互来完成特定网络应用。对应于OSI参考模型的（应用层、表示层、会话层），应用层协议很多，如**域名系统DNS**，HTTP协议，支持电子邮件的 **SMTP协议**等等。我们把应用层交互的数据单元称为报文。
- 传输层：负责向两台主机进程之间的通信提供通用的数据传输服务。对应OSI参考模型的传输层，协议有传输控制协议 TCP 和 用户数据协议 UDP。
- 网络层：对应OSI参考模型的的网络层
- 数据链路层：对应OSI参考模型的的数据链路层
- 物理层：对应OSI参考模型的的物理层层。在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

### 7.  POST和GET有哪些区别？

- **请求参数**：GET 把参数包含在 URL 中，用&连接起来；POST 通过 request body 传递参数。
- **请求缓存**：GET请求会被主动Cache，而POST请求不会，除非手动设置。
- **收藏为书签**：GET请求支持收藏为书签，POST请求不支持。
- **安全性**：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。
- **历史记录**：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。
- **编码方式**：GET请求只能进行url编码，而POST支持多种编码方式。
- **参数数据类型**：GET只接受ASCII字符，而POST没有限制数据类型。
- **数据包**: GET产生一个TCP数据包；POST可能产生两个TCP数据包。

### 8. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？

在 HTTP 中响应体的 Connection 字段指定为`keep-alive`

### 9. HTTP 如何实现长连接？在什么时候会超时？

**HTTP 如何实现长连接？**

- HTTP分为长连接和短连接，其实**本质上说的是TCP的长短连接**。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一个说法。
- 长连接是指的是TCP连接，而不是HTTP连接。
- TCP 长连接可以复用一个TCP连接来发起多次HTTP请求，这样可以减少资源消耗，比如一次请求HTML，短连接可能还需要请求后续的JS/CSS/图片等

要实现HTTP长连接，在响应头设置**Connection为keep-alive**，HTTP1.1 默认是长连接，而HTTP 1.0协议也支持长连接，但是默认是关闭的。

**在什么时候会超时呢？**

- HTTP 一般会有httpd守护进程，里面可以设置 keep-alive timeout，当 tcp 链接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间
- TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置：当 TCP 连接之后，闲置了 tcp_keep alive_time，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 tcp_keep alive_probes，就会丢弃该连接。

1. tcp_keepalive_intvl = 15
2. tcp_keepalive_probes = 5
3. tcp_keepalive_time = 1800

### 10. 讲一下HTTP与HTTPS 的区别。

HTTP，超文本传输协议，英文是**Hyper Text Transfer Protocol**，是一个基于TCP/IP通信协议来传递数据的协议。HTTP存在这**几个问题**：

- 请求信息明文传输，容易被窃听截取。
- 数据的完整性未校验，容易被篡改
- 没有验证对方身份，存在冒充危险

HTTPS就是为了解决HTTP存在问题的。HTTPS，英文是HyperText Transfer Protocol over Secure Socket Layer，可以这么理解Https是身披SSL(Secure Socket Layer)的HTTP，即**HTTPS 协议 = HTTP+SSL/TLS**。通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的传输数据进行**加密**。

它们主要区别：

- 数据是否加密: Http 是明文传输，HTTPS是密文
- 默认端口: Http默认端口是80，Https默认端口是443
- 资源消耗：和HTTP通信相比，Https通信会消耗更多的CPU和内存资源，因为需要加解密处理；
- 安全性: http不安全，https比较安全。

### 11 .  Https 流程是怎样的？

- HTTPS = HTTP + SSL/TLS，即用SSL/TLS对数据进行加密和解密，Http进行传输。
- SSL，即Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。
- TLS，即Transport Layer Security(安全传输层协议)，它是SSL 3.0的后续版本。

<img src="images/cb9a2a86936a46ceaadb5d46878659c8tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="Https工作流程" width="50%" />

1. 用户在浏览器里输入一个https网址，然后连接到server的443端口。
2. 服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过。这套证书其实就是一对公钥和私钥。
3. 服务器将自己的数字证书（含有公钥）发送给客户端。
4. 客户端收到服务器端的数字证书之后，会对其进行检查，如果不通过，则弹出警告框。如果证书没问题，则生成一个密钥（对称加密），用证书的公钥对它加密。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。
7. 服务器将加密后的密文返回给客户端。
8. 客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数据。

### 12. 对称加密与非对称加密有什么区别

对称加密：加密和解密使用相同密钥的加密算法。

<img src="images/fee86a5c2e0346ef86b65c6def4128edtplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="对称加密" width="60%" />

非对称加密：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。

<img src="images/b5ad92adfef64599a2124cc4e5a92e64tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="非对称加密" width="60%" />

### 13. 什么是XSS攻击，如何避免?

XSS 攻击，全称**跨站脚本攻击（Cross-Site Scripting）**，这会与层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，因此有人将跨站脚本攻击缩写为XSS。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。XSS攻击一般分三种类型：**存储型 、反射型 、DOM型XSS**

**XSS是如何攻击的？**

拿反射型举个例子吧，流程图如下：

<img src="images/53d2408390e34b9faaa48e44c09fd4f8tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="60%" />

**如何解决XSS攻击问题**

- 不相信用户的输入，对输入进行过滤，过滤标签等，只允许合法值。
- HTML 转义
- 对于链接跳转，如` <a href="xxx"` 等，要校验内容，禁止以script开头的非法链接。
- 限制输入长度等等

### 14. 请详细介绍一下TCP 的三次握手机制

<img src="images/7eb38a6e24f64c78b6fe5e49ba6a8c0ctplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="TCP三次握手" width="35%" />

开始客户端和服务器都处于 CLOSED 状态，然后服务端开始监听某个端口，进入 LISTEN 状态

- 第一次握手(SYN=1, seq=x)，发送完毕后，客户端进入 SYN_SEND 状态
- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端进入 SYN_RCV状态。
- 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时

### 15. TCP握手为什么是三次，不能是两次？不能是四次？

TCP握手为什么是三次呢？为了方便理解，我们以谈恋爱为个例子：两个人能走到一起，最重要的事情就是相爱，就是**我爱你，并且我知道，你也爱我**，接下来我们以此来模拟三次握手的过程：

<img src="images/2d2fc14beb36429891827782b95b7cc9tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="25%" />

**为什么握手不能是两次呢？**

如果只有两次握手，女孩子可能就不知道，她的那句**我也爱你**，男孩子是否**收到**，恋爱关系就不能愉快展开。

**为什么握手不能是四次呢？**

因为握手不能是四次呢？因为三次已经够了，三次已经能让双方都知道：你爱我，我也爱你。而四次就多余了。

### 16.  TCP四次挥手过程?

<img src="images/999957de66e746998b6b5ccfe0b15aaftplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="TCP四次挥手过程" width="40%" />

1. 第一次挥手(FIN=1，seq=u)，发送完毕后，客户端进入FIN_WAIT_1 状态
2. 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态
3. 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入LAST_ACK 状态，等待来自客户端的最后一个ACK。
4. 第四次挥手(ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，**等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后**，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

### 17. TCP四次挥手过程中，客户端为什么需要等待 2MSL,才进入CLOSED状态

<img src="images/568a9da479bc4d8bbbb3c5534270206btplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="40%" />

2MSL，2 Maximum Segment Lifetime，即两个最大段生命周期

> - 1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端
> - 1个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达

主要有两个原因：

1. 确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。

   第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN/ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN/ACK 报文的确认，就无法正常断开连接。

   MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN/ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。

   如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。

2.  防止已失效的连接请求报文段出现在之后的连接中。

    TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。

### 18. 为什么需要四次挥手？

- 第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认。

  - 序列号 seq = u，即客户端上次发送的报文的最后一个字节的序号 + 1
  - 确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1

- 第二次挥手：服务端收到连接释放报文后，立即发出**确认报文**（ACK=1），序列号 seq = k，确认号 ack = u + 1。

  这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。

- 第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认。

  - 序列号 seq = w，即服务端上次发送的报文的最后一个字节的序号 + 1。
  - 确认号 ack = u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据

- 第四次挥手：客户端收到服务端的连接释放报文后，立即发出**确认报文**（ACK=1），序列号 seq = u + 1，确认号为 ack = w + 1。

  此时，客户端就进入了 `TIME-WAIT` 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 `CLOSED` 状态。而服务端只要收到客户端发出的确认，就立即进入 `CLOSED` 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。

举个例子吧

> 小明和小红打电话聊天，通话差不多要结束时，小红说“我没啥要说的了”，小明回答“我知道了”。但是小明可能还会有要说的话，小红不能要求小明跟着自己的节奏结束通话，于是小明可能又叽叽歪歪说了一通，最后小明说“我说完了”，小红回答“知道了”，这样通话才算结束。

<img src="images/5299fcab7ef14dfab97bc10312b66539tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="25%" />



### 19. 为什么连接的时候是三次握手，关闭的时候却是四次握手？

服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段.

接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的**ACK和FIN一般都会分开发送**，从而导致多了一次，因此一共需要四次挥手。

### 20. 如果已经建立了连接，但是客户端出现故障了怎么办？

或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。

简而言之，通过**定时器 + 超时重试机制**，尝试获取确认，直到最后会自动断开连接。

具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。

### 21. TIME-WAIT 状态过多会产生什么后果？怎样处理？

从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。

从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。

**解决办法：**

* 服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于
  TIME_WAIT状态），也请继续并重用它。

* 调整系统内核参数，修改/etc/sysctl.conf文件，即修改`net.ipv4.tcp_tw_reuse 和 tcp_timestamps`

  ```bash
  net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
  net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
  ```

* 强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。

### 22. TIME_WAIT 是服务器端的状态?还是客户端的状态?

TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般设置不主动关闭连接。

TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。

### 23. TCP协议如何保证可靠性？

TCP主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和 流量控制等方法实现了可靠性传输。

* 检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。

* 序列号/确认应答：

  序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。

  TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

* 滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。

* 超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。

* 拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。

*  流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。

### 24. 详细讲一下TCP的滑动窗口？

在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。

为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。

<img src="images/image-20210520214432214.png" width="70%" />

从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。

滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。

可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。

### 25. Session和Cookie的区别。

**我们先来看Session和Cookie的定义：**

- Cookie是服务器发送到用户浏览器，并保存在浏览器本地的一小块文本串数据。它会在浏览器下次向同一服务器再发起请求时，被携带发送到服务器。通常，它用于告知服务端两个请求是否来自同一浏览器，一样用于保持用户的登录状态等。Cookie使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。
- session指的就是服务器和客户端一次会话的过程。 Session利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。Session对象存储着特定用户会话所需的属性及配置信息。

**Session 和 Cookie 到底有什么不同呢？**

- 存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。
- 存储数据类型不一样，Cookie 只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。
- 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- 存储大小不同， 单个Cookie保存的数据不能超过4K，Session可存储数据远高于 Cookie。

来看个图吧：

<img src="images/7962ae1569724f6996da566cc6291317tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="50%" />

- 用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的Session ，请求返回时将此Session的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入Cookie 中，同时 Cookie 记录此SessionID 属于哪个域名。
- 当用户第二次访问服务器时，请求会自动判断此域名下是否存在Cookie信息，如果存在，则自动将Cookie信息也发送给服务端，服务端会从Cookie中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

### 26. 如何考虑分布式 Session 问题？

在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

分布式 Session 一般会有以下几种解决方案：

* **客户端存储**：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息

- **Nginx ip_hash 策略**：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。
- **Session 复制**：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。
- **共享 Session**：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。

建议采用共享 Session的方案。

### 27. TCP 是如何保证可靠性的

- 首先，TCP的连接是基于**三次握手**，而断开则是**四次挥手**。确保连接和断开的可靠性。
- 其次，TCP的可靠性，还体现在**有状态**;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在**可控制**。它有数据包校验、ACK应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

### 28. TCP 和 UDP 的区别

|              | UDP                                        | TCP                                              |
| :----------- | :----------------------------------------- | :----------------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                                         |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制                 |
| 是否有序     | 无序                                       | 有序，消息在传输过程中可能会乱序，TCP 会重新排序 |
| 传输速度     | 快                                         | 慢                                               |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                                 |
| 传输方式     | 面向报文                                   | 面向字节流                                       |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节                       |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输           |

**总结**：

TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。

### 29. TCP报文首部有哪些字段，说说其作用

<img src="images/faf0c955f1994f58a8aeb0a79c8e05d4tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="60%" />

- **16位端口号**：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序
- **32位序号**：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。
- **32位确认号**：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。
- **4位头部长度**：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。
- **6位标志位**：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）
- **16位窗口大小**：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
- **16位校验和**：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。
- **16位紧急指针**：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

### 30. HTTP状态码301和302的区别？

- 301:（永久移动）请求的网页已被永久移动到新位置。服务器返回此响应（作为对GET或HEAD请求的响应）时，会自动将请求者转到新位置。
- 302:（临时移动）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。

HTTP状态码301与302的区别：

1. 它们之间关键区别在，资源是否存在有效性；
2. 301资源还在只是换了一个位置，返回的是新位置的内容；
3. 302资源暂时失效，返回的是一个临时的代替页上。

### 31. 聊聊TCP 的重传机制

#### 1 超时重传

TCP 为了实现可靠传输，实现了重传机制。最基本的重传机制，就是**超时重传**，即在发送数据报文时，设定一个定时器，每间隔一段时间，没有收到对方的ACK确认应答报文，就会重发该报文。

这个间隔时间，一般设置为多少呢？我们先来看下什么叫**RTT（Round-Trip Time，往返时间）**。

<img src="images/42b43a27f8a14415bd9179c95f58ed99tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="40%" />

RTT就是，一个数据包从发出去到回来的时间，即**数据包的一次往返时间**。超时重传时间，就是Retransmission Timeout ，简称**RTO**。

**RTO设置多久呢？**

- 如果RTO比较小，那很可能数据都没有丢失，就重发了，这会导致网络阻塞，会导致更多的超时出现。
- 如果RTO比较大，等到花儿都谢了还是没有重发，那效果就不好了。

一般情况下，RTO略大于RTT，效果是最好的。一些小伙伴会问，超时时间有没有计算公式呢?有的！有个标准方法算RTO的公式，也叫**Jacobson / Karels 算法**。我们一起来看下计算RTO的公式

**1. 先计算SRTT（计算平滑的RTT）**

```c
SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均
```

**2. 再计算RTTVAR (round-trip time variation)**

```c
RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距
```

**3. 最终的RTO**

```c
RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR  
```

其中，`α = 0.125，β = 0.25， μ = 1，∂ = 4`，这些参数都是大量结果得出的最优参数。

但是，超时重传会有这些缺点：

> - 当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。
> - 当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。

并且，TCP有个策略，就是超时时间间隔会加倍。超时重传需要**等待很长时间**。因此，还可以使用**快速重传**机制。

#### 2 快速重传

**快速重传**机制，它不以时间驱动，而是以数据驱动。它基于接收端的反馈信息来引发重传。

一起来看下快速重传流程：

<img src="images/1639c47f009d40908832aebe094e816dtplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="快速重传流程" width="40%" />

发送端发送了 1，2，3，4，5,6 份数据:

- 第一份 Seq=1 先送到了，于是就 Ack 回 2；
- 第二份 Seq=2 也送到了，假设也正常，于是ACK 回 3；
- 第三份 Seq=3 由于网络等其他原因，没送到；
- 第四份 Seq=4 也送到了，但是因为Seq3没收到。所以ACK回3；
- 后面的 Seq=4,5的也送到了，但是ACK还是回复3，因为Seq=3没收到。
- 发送端连着收到三个重复冗余ACK=3的确认（实际上是4个，但是前面一个是正常的ACK，后面三个才是重复冗余的），便知道哪个报文段在传输过程中丢失了，于是在定时器过期之前，重传该报文段。
- 最后，接收到收到了 Seq3，此时因为 Seq=4，5，6都收到了，于是ACK回7.

但**快速重传**还可能会有个问题：ACK只向发送端告知最大的有序报文段，到底是哪个报文丢失了呢？**并不确定**！那到底该重传多少个包呢？

> 是重传 Seq3 呢？还是重传 Seq3、Seq4、Seq5、Seq6 呢？因为发送端并不清楚这三个连续的 ACK3 是谁传回来的。

#### 3 带选择确认的重传（SACK）

为了解决快速重传的问题：**应该重传多少个包**? TCP提供了**SACK方法**（带选择确认的重传，Selective Acknowledgment）。

**SACK机制**就是，在快速重传的基础上，接收端返回最近收到的报文段的序列号范围，这样发送端就知道接收端哪些数据包没收到，酱紫就很清楚该重传哪些数据包啦。SACK标记是加在TCP头部**选项**字段里面的。

<img src="images/0021dd191c0a4b80a5a2ab21c561cd2ftplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="SACK机制" width="60%" />

如上图中，发送端收到了三次同样的ACK=30的确认报文，于是就会触发快速重发机制，通过SACK信息发现只有`30~39`这段数据丢失，于是重发时就只选择了这个`30~39`的TCP报文段进行重发。

#### 4 D-SACK

D-SACK，即Duplicate SACK（重复SACK），在SACK的基础上做了一些扩展，，主要用来告诉发送方，有哪些数据包自己重复接受了。DSACK的目的是帮助发送方判断，是否发生了包失序、ACK丢失、包重复或伪重传。让TCP可以更好的做网络流控。来看个图吧：

<img src="images/b341663b47134f0d9435f51f3f3ae9ectplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="D-SACK简要流程" width="60%" />

### 32. IP地址有哪些分类？

一句话概括，IP地址 = 网络号+主机号。

1. 网络号：它标志主机（或路由器）所连接到的网络，网络地址表示属于互联网的哪一个网络
2. 主机号：它标志该主机（或路由器），主机地址表示其属于该网络中的哪一台主机

IP地址 分为A，B，C，D，E 五大类：

- A类地址(1~126)：以0开头，网络号占前8位，主机号占后24位。
- B类地址(128~191)：以10开头，网络号占前16位，主机号占后16位。
- C类地址(192~223)：以110开头，网络号占前24位，主机号占后8位。
- D类地址(224~239)：以1110开头，保留位多播地址。
- E类地址(240~255)：以11110开头，保留位为将来使用

<img src="images/5ce0ced22926454baeba0b8bb56ec379tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="IP地址分类" width="70%" />

### 33. 聊聊TCP的滑动窗口

TCP 发送一个数据，需要收到确认应答，才会发送下一个数据。这样有个缺点，就是效率会比较低。

> 这就好像我们面对面聊天，你说完一句，我应答后，你才会说下一句。那么，如果我在忙其他事情，没有能够及时回复你。你说完一句后，要等到我忙完回复你，你才说下句，这显然很不现实。

为了解决这个问题，TCP引入了**窗口**，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。

TCP头部有个字段叫win，也即那个**16位的窗口大小**，它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到**流量控制**的目的。

> 通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是win。

TCP 滑动窗口分为两种: 发送窗口和接收窗口。**发送端的滑动窗口**包含四大部分，如下：

- 已发送且已收到ACK确认
- 已发送但未收到ACK确认
- 未发送但可以发送
- 未发送也不可以发送

<img src="images/8cfb5c0a87b04b7396ede33338d29fdctplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="50%" />

- 虚线矩形框，就是发送窗口。
- SND.WND: 表示发送窗口的大小,上图虚线框的格子数就是14个。
- SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。
- SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。

接收方的滑动窗口包含三大部分，如下：

- 已成功接收并确认
- 未收到数据但可以接收
- 未收到数据并不可以接收的数据

<img src="images/a72b926a2e8b4b7296f497e5c12d17fatplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="50%" />

- 虚线矩形框，就是接收窗口。
- REV.WND: 表示接收窗口的大小,上图虚线框的格子就是9个。
- REV.NXT:下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。

### 34. 聊聊五层计算机网络体系结构中，每一层对应的网络协议有哪些？

<img src="images/dd4ca9006d4343e4bbde301e82574d94tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="60%" />

### 35. 聊聊TCP的流量控制

TCP三次握手，发送端和接收端进入到ESTABLISHED状态，它们即可以愉快地传输数据啦。

但是发送端不能疯狂地向接收端发送数据，因为接收端接收不过来的话，接收方只能把处理不过来的数据存在缓存区里。如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源啦。

> TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是**流量控制**。

TCP通过滑动窗口来控制流量，我们看下流量控制的**简要流程**吧：

首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。

<img src="images/4be458d1adc446b98c6e93f9c3c5d437tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="TCP的流量控制" width="50%" />

1. 假如当前发送方给接收方发送了200个字节，那么，发送方的`SND.NXT`会右移200个字节，也就是说当前的可用窗口减少了200 个字节。
2. 接受方收到后，放到缓冲队列里面，REV.WND =400-200=200字节，所以win=200字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口200字节
3. 发送方又发送200字节过来，200字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理100字节，剩余的100字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100字节，即win=100返回发送方。
4. 发送方继续干活，发送100字节过来，这时候，接受窗口win变为0。
5. 发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到win大于0，才继续开始发送。

### 36. 说下ARP 协议的工作原理？

ARP 协议协议，即**Address Resolution Protocol**，地址解析协议，用于实现IP地址到MAC地址的映射。

1. 首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。
2. 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的ARP列表，是否存在该IP地址对应的MAC地址；如果存在﹐就直接将数据包发送到这个MAC地址；如果不存在，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求的数据包里，包括源主机的IP地址、硬件地址、以及目的主机的IP地址。
3. 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。
4. 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

### 37. 说下TCP的拥塞控制

拥塞控制是**作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况**。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟**流量控制**又有什么区别呢？流量控制是作用于接收者的，根据**接收端的实际接收能力控制发送速度**，防止分组丢失的。

我们可以把网络链路比喻成一根水管，如果我们想最大化利用网络来传输数据，那就是尽快让水管达到最佳充满状态。

<img src="images/6e3d3b5192154462a09fdbd9eedd27betplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="40%" />

发送方维护一个**拥塞窗口cwnd（congestion window）** 的变量，用来估算在一段时间内这条链路（水管）可以承载和运输的数据（水）的数量。它大小代表着网络的拥塞程度，并且是动态变化的，但是为了达到最大的传输效率，我们该如何知道这条水管的运送效率是多少呢？

一个比较简单的方法就是不断增加传输的水量，直到水管快要爆裂为止（对应到网络上就是发生丢包），用 TCP 的描述就是：

> 只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。

实际上，拥塞控制主要有这几种常用算法

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

#### 1 慢启动算法

慢启动算法，表面意思就是，别急慢慢来。它表示TCP建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，**每收到一个ACK，就将拥塞窗口cwnd大小就加1（单位是MSS）**。**每轮次**发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。

- TCP连接完成，初始化cwnd = 1，表明可以传一个MSS单位大小的数据。
- 每当收到一个ACK，cwnd就加一;
- 每当过了一个RTT，cwnd就增加一倍; 呈指数让升

<img src="images/df48b0049c414a0ca6e2c2027ce8083ftplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="35%" />

为了防止cwnd增长过大引起网络拥塞，还需设置一个**慢启动阀值ssthresh**（slow start threshold）状态变量。当`cwnd`到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当**cwnd >ssthresh**时，进入了**拥塞避免**算法。

#### 2 拥塞避免算法

一般来说，慢启动阀值ssthresh是65535字节，`cwnd`到达**慢启动阀值**后

- 每收到一个ACK时，cwnd = cwnd + 1/cwnd
- 当每过一个RTT时，cwnd = cwnd + 1

显然这是一个线性上升的算法，避免过快导致网络拥塞问题。

<img src="images/cb1a2aec9cf84b6199c0e99fde98ecf6tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="50%" />

#### 3 拥塞发生

当网络拥塞发生**丢包**时，会有两种情况：

- RTO超时重传
- 快速重传

如果是发生了**RTO超时重传**，就会使用拥塞发生算法

- 慢启动阀值sshthresh =  cwnd /2
- cwnd 重置为 1
- 进入新的慢启动过程

<img src="images/709034deea1145e2aab881f64f2d67e2tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="60%" />

这真的是**辛辛苦苦几十年，一朝回到解放前**。其实还有更好的处理方式，就是**快速重传**。发送方收到3个连续重复的ACK时，就会快速地重传，不必等待**RTO超时**再重传。

<img src="images/e5f5ca98465c40b0936ed83aba2ffc15tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="image.png" width="40%" />

慢启动阀值ssthresh 和 cwnd 变化如下：

- 拥塞窗口大小 cwnd = cwnd/2
- 慢启动阀值 ssthresh = cwnd
- 进入快速恢复算法

#### 4 快速恢复

快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有3个重复ACK收到，说明网络也没那么糟糕，所以没有必要像RTO超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 sshthresh已被更新：

```
- cwnd = cwnd /2
- sshthresh = cwnd
```

然后，真正的快速算法如下：

- cwnd = sshthresh  + 3
- 重传重复的那几个ACK（即丢失的那几个数据包）
- 如果再收到重复的 ACK，那么 cwnd = cwnd +1
- 如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。

<img src="images/085337a6b11d41c4a4bf975f8217eb24tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="60%" />

### 38. TCP 和 UDP 分别对应的常见应用层协议有哪些？

**基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH**

- **HTTP**：HyperText Transfer Protocol（超文本传输协议），默认端口80
- **FTP**: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)
- **SMTP**: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25
- **TELNET**: Teletype over the Network (网络电传), 默认端口23
- **SSH**： Secure Shell（安全外壳协议），默认端口 22

**基于UDP的应用层协议：DNS、TFTP、SNMP**

- **DNS** : Domain Name Service (域名服务),默认端口 53
- **TFTP**: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69
- **SNMP**：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。

### 39. 半连接队列和 SYN Flood 攻击的关系

TCP进入三次握手前，服务端会从**CLOSED**状态变为**LISTEN**状态,同时在内部创建了两个队列：半连接队列（SYN队列）和全连接队列（ACCEPT队列）。

什么是**半连接队列（SYN队列）** 呢? 什么是**全连接队列（ACCEPT队列）** 呢？回忆下TCP三次握手的图：

<img src="images/67e2444df1934f549e7509fb5ce4b561tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="三次握手" width="35%" />

- TCP三次握手时，客户端发送SYN到服务端，服务端收到之后，便回复**ACK和SYN**，状态由**LISTEN变为SYN_RCVD**，此时这个连接就被推入了**SYN队列**，即半连接队列。
- 当客户端回复ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入ACCEPT队列，即全连接队列。

SYN Flood是一种典型的DoS (Denial of Service，拒绝服务) 攻击，它在短时间内，伪造**不存在的IP地址**,向服务器大量发起SYN报文。当服务器回复SYN+ACK报文后，不会收到ACK回应报文，导致服务器上建立大量的半连接半连接队列满了，这就无法处理正常的TCP请求啦。

主要有 **syn cookie**和**SYN Proxy防火墙**等方案应对。

- **syn cookie**：在收到SYN包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个cookie值作为自己的SYNACK包的序列号，回复SYN+ACK后，服务器并不立即分配资源进行处理，等收到发送方的ACK包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
- **SYN Proxy防火墙**：服务器防火墙会对收到的每一个SYN报文进行代理和回应，并保持半连接。等发送方将ACK包返回后，再重新构造SYN包发到服务器，建立真正的TCP连接。

### 40. 聊聊保活计时器的作用

除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75秒钟发送一次。若连续发送10个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。

### 41. 聊聊ARP协议

ARP协议，地址解析协议，是一个由IP地址获取MAC物理地址的TCP/IP协议。

**什么是IP地址，什么是MAC地址？**

- IP地址：是互联网协议地址，它是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。
- MAC地址：以太网地址或物理地址，它是一个用来确认网络设备位置的位址。

**为什么需要ARP协议呢？**

> - 在网络访问层中，同一局域网中的一台主机要和另一台主机进行通信，需要通过MAC地址进行定位，然后才能进行数据包的发送。
> - 而在网络层和传输层中，计算机之间是通过IP地址定位目标主机，对应的数据报文只包含目标主机的IP地址，而没有 MAC 地址。
> - 因此，在发送之前需要根据IP地址获取 MAC 地址，然后才能将数据包发送到正确的目标主机，而这个获取过程是通过ARP协议完成的。

**ARP的工作流程**

<img src="images/fb92608a0dea4a2aa19173ec4f529555tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="60%" />

当主机A与主机B要通信时，工作流程如下：

1. 查询本地ARP缓存表,看是否有IP地址及其对应的MAC地址。
2. 如果没匹配到主机B的MAC地址，主机A会在局域网内广播发送一个ARP请求分组，局域网内所有主机都会收到该请求分组。
3. 主机B收到请求分组报文，发现报文中的IP与自己匹配，就A的IP和MAC地址添加到本地ARP缓存表中。
4. 主机B向主机A响应一个含自身MAC地址的报文。
5. 主机A收到报文后，将B的IP和MAC地址添加至ARP缓存表中。

### 42. TCP的粘包和拆包

TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一**个完整的包可能会被TCP拆分成多个包进行发送**，**也有可能把多个小的包封装成一个大的数据包发送**，这就是所谓的TCP粘包和拆包问题。

<img src="images/b36ee4ffabc548d299336e966715579etplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="TCP的粘包和拆包" width="50%" />

**为什么会产生粘包和拆包呢?**

- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。

**解决方案：**

- 发送端将每个数据包封装为固定长度
- 在数据尾部增加特殊字符进行分割
- 将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。

### 43.  forward 和 redirect 的区别？

- **直接转发方式（Forward）** ，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。
- **间接转发方式（Redirect）** 实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。

举个通俗的例子：

> - 直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；
> - 间接转发就相当于："A找B借钱，B说没有，让A去找C借"。**

看这两个图，可以更容易理解一些:

- Redirect 的工作原理：

<img src="images/47e813089721438cacfd053508e026fdtplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="40%" />

- forward 的工作原理

<img src="images/63ddebd73b274d17bd6f9135889d8c49tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="40%" />

### 44. Nagle 算法与延迟确认

#### 1 Nagle算法

如果发送端疯狂地向接收端发送很小的包，比如就1个字节，那么亲爱的小伙伴，你们觉得会有什么问题呢？

> TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。**Nagle算法**就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。

Nagle算法的基本定义是：**任意时刻，最多只能有一个未被确认的小段**。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。

Nagle算法的实现规则：

- 如果包长度达到MSS，则允许发送；
- 如果该包含有FIN，则允许发送；
- 设置了TCP_NODELAY选项，则允许发送；
- 未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
- 上述条件都未满足，但发生了超时（一般为200ms），则立即发送。

#### 2 延迟确认

如果接受方刚接收到发送方的数据包，在很短很短的时间内，又接收到第二个包。那么请问接收方是一个一个地回复好点，还是合并一起回复好呢？

> 接收方收到数据包后，如果暂时没有数据要发给对端，它可以等一段时再确认（Linux上默认是40ms）。如果这段时间刚好有数据要传给对端，ACK就随着数据传输，而不需要单独发送一次ACK。如果超过时间还没有数据要发送，也发送ACK，避免对端以为丢包。

但是有些场景不能延迟确认，比如发现了**乱序包**、**接收到了大于一个 frame 的报文，且需要调整窗口大小**等。

一般情况下，**Nagle算法和延迟确认**不能一起使用，Nagle算法意味着延迟发，**延迟确认**意味着延迟接收，酱紫就会造成更大的延迟，会产生性能问题。

### 45. URI和URL的区别

- URI，全称是Uniform Resource Identifier)，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。
- URL，全称是Uniform Resource Location)，中文翻译是统一资源定位符，主要作用是提供资源的路径。

打个经典比喻吧，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。

### 46. 什么是数字签名？ 什么是数字证书？

了解过**Https原理**的小伙伴，都知道数字证书这玩意。为了避免公钥被篡改，引入了数字证书，如下：

<img src="images/1427d1c705264e48bfc2a2aa32e23bf6tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="50%" />

**数字证书构成**

- 公钥和个人信息，经过Hash算法加密，形成消息摘要；将消息摘要拿到拥有公信力的认证中心（CA），用它的私钥对消息摘要加密，形成数字签名.
- 公钥和个人信息、数字签名共同构成数字证书。

### 47. 什么是SQL 注入？举个例子？

SQL注入是一种代码注入技术，一般被应用于攻击web应用程序。它通过在 web 应用接口传入一些特殊参数字符，来欺骗应用服务器，执行恶意的SQL命令，以达到非法获取系统信息的目的。它目前是黑客对数据库进行攻击的最常用手段之一。

#### SQL注入是如何攻击的？

举个常见的**业务场景**：在web表单搜索框输入员工名字，然后后台查询出对应名字的员工。

<img src="images/a18629e6e3574850ae25bf1fde31d203tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="40%" />

这种场景下，一般都是前端页面把一个名字参数name传到后台，然后后台通过SQL把结果查询出来

```
name = "田螺"; //前端传过来的

SQL= "select * from staff where name=" + name;  //根据前端传过来的name参数，查询数据库员工表staff
```

因为SQL是直接拼接的，如果我们完全信任前端传的参数的话。假如前端传这么一个参数时`'' or '1'='1'`，SQL就变成酱紫的啦。

```
select * from staff where name='' or '1'='1';
```

这个SQL会把所有的员工信息全都查出来了，酱紫就请求用户已经越权啦。请求者可以获取所有员工的信息，信息已经暴露了啦。

#### 如何预防SQL注入问题

**1). 使用#{}而不是${}**

在MyBatis中,使用`#{}`而不是`${}`，可以很大程度防止sql注入。

- 因为`#{}`是一个参数占位符，对于字符串类型，会自动加上""，其他类型不加。由于Mybatis采用**预编译**，其后的参数不会再进行SQL编译，所以一定程度上防止SQL注入。
- `${}`是一个简单的字符串替换，字符串是什么，就会解析成什么，存在SQL注入风险

**2). 不要暴露一些不必要的日志或者安全信息，比如避免直接响应一些sql异常信息。**

如果SQL发生异常了，不要把这些信息暴露响应给用户，可以自定义异常进行响应

**3). 不相信任何外部输入参数，过滤参数中含有的一些数据库关键词关键词**

可以加个参数校验过滤的方法，过滤`union，or`等数据库关键词

**4). 适当的权限控制**

在你查询信息时，先校验下当前用户是否有这个权限。比如说，实现代码的时候，可以让用户多传一个企业Id什么的，或者获取当前用户的session信息等，在查询前，先校验一下当前用户是否是这个企业下的等等，是的话才有这个查询员工的权限。

### 48. 什么是DoS、DDoS、DRDoS攻击？

- **DOS**: (Denial of Service),中文名称是拒绝服务,一切能引起DOS行为的攻击都被称为DOS攻击。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。
- **DDoS**: (Distributed Denial of Service),中文名称是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。常见的DDos有SYN Flood、Ping of Death、ACK Flood、UDP Flood等。
- **DRDoS**: (Distributed Reflection Denial of Service)，中文名称是分布式反射拒绝服务，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，形成拒绝服务攻击。

### 49. WebSocket与socket的区别

- Socket = IP地址 + 端口 + 协议。

> 具体来说，Socket是一套标准，它完成了对TCP/IP的高度封装，屏蔽网络细节以方便开发者更好地进行网络编程。

- WebSocket是一个持久化的协议，它是伴随HTTP5而出的协议，用来解决**http不支持持久化连接**的问题。
- Socket一个是**网编编程的标准接口**，而WebSocket是应用层通信协议。

### 50.  ICMP协议的功能

ICMP,Internet Control Message Protocol ,Internet控制消息协议。

- ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。
- 它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括**报告错误、交换受限控制和状态信息**等。
- 当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。

比如我们日常使用得比较多的**ping**，就是基于ICMP的。

### 51. Http请求的过程与原理

HTTP是一个基于TCP/IP协议来传递数据的超文本传输协议，传输的数据类型有HTML文件,、图片文件等。以访问百度有例子，看下一次Http的请求过程

<img src="images/8159221088274e8892794e7ec8ac3df7tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="Http请求过程" width="60%" />

1. 客户端进行DNS域名解析，得到对应的IP地址
2. 根据这个IP，找到对应的服务器建立连接（三次握手）
3. 建立TCP连接后发起HTTP请求（一个完整的http请求报文）
4. 服务器响应HTTP请求，客户端得到html代码
5. 客户端解析html代码，用html代码中的资源(如js,css,图片等等)渲染页面。
6. 服务器关闭TCP连接（四次挥手）

### 52. 说下ping的原理

> ping，**Packet Internet Groper**，是一种因特网包探索器，用于测试网络连接量的程序。Ping是工作在TCP/IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态

一般来说，ping可以用来检测网络通不通。它是基于`ICMP`协议工作的。假设**机器A** ping**机器B**，工作过程如下：

1. ping通知系统，新建一个固定格式的ICMP请求数据包
2. ICMP协议，将该数据包和目标机器B的IP地址打包，一起转交给IP协议层
3. IP层协议将本机IP地址为源地址，机器B的IP地址为目标地址，加上一些其他的控制信息，构建一个IP数据包
4. 先获取目标机器B的MAC地址。
5. 数据链路层构建一个数据帧，目的地址是IP层传过来的**MAC地址**，源地址是本机的**MAC地址**
6. 机器B收到后，对比目标地址，和自己本机的MAC地址是否一致，符合就处理返回，不符合就丢弃。
7. 根据目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间
8. 最终显示结果有这几项：发送到目的主机的IP地址、发送 & 收到 & 丢失的分组数、往返时间的最小、最大& 平均值

### 53. 如果服务器出现了大量 CLOSE_WAIT 状态如何解决。

我们先来回忆下TCP的四次挥手

<img src="images/9fe15ac1c6b5425f924535821f998771tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" width="40%" />

- 服务器端收到客户端发送的`FIN`后，TCP协议栈就会自动发送ACK，接着进入**CLOSE_WAIT**状态。
- 但是如果服务器端不执行socket的close()操作，那么就没法进入LAST_ACK,导致大量连接处于CLOSE_WAIT状态
- 所以，如果服务器出现了大量**CLOSE_WAIT**状态，一般是程序Bug，或者关闭socket不及时。

### 54. 什么是CSRF攻击，如何避免

**什么是CSRF 攻击？**

CSRF，跨站请求伪造（英语：Cross-site request forgery），简单点说就是，攻击者盗用了你的身份，以你的名义发送恶意请求。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

**CSRF是如何攻击的呢？**

<img src="images/67839b33223c4e958349b67b11acdc01tplv.png" alt="67839b33223c4e958349b67b11acdc01tplv" width="50%" />

- Tom 登陆银行，没有退出，浏览器包含了Tom在银行的身份认证信息。
- 黑客Jerry将伪造的转账请求，包含在在帖子
- Tom在银行网站保持登陆的情况下，浏览帖子
- 将伪造的转账请求连同身份认证信息，发送到银行网站
- 银行网站看到身份认证信息，以为就是Tom的合法操作，最后造成Tom资金损失。

**如何解决CSRF攻击**

- 检查Referer字段。HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。
- 添加校验token。

### 55. RARP协议的工作原理？

- ARP(地址解析协议) ,是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议。
- RARP(反向地址转换协议)以与ARP相反的方式工作。RARP发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址。（应用于无盘机）

RARP 工作原理如下：

1. 发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；
2. 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；
3. 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；
4. 如果不存在，RARP服务器对此不做任何的响应；
5. 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。

### 56. 负载均衡算法有哪些？

多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。

- 轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。
- 随机法：随机获取一台，和轮询类似。
- 哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。
- 加权轮询：根据服务器性能不同加权。

### 57. 有了IP地址，为什么还要用MAC地址？

- 简而言之，标识网络中的一台计算机，比较常用的就是**IP地址和MAC地址**，但计算机的IP地址可由用户自行更改，管理起来就相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。
- 那只使用MAC地址不用IP地址行不行呢？不行的！因为最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。
- 那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。
- IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。

### 58. 了解下DNS，解析过程？

DNS，**domain name system**，域名解析系统，是因特网上作为域名和IP地址相互映射的一个分布式数据库。它的作用非常简单，就是可以根据域名查出对应的IP地址。

解析过程如下：

1. 首先，检查**浏览器缓存**中，查找对应的IP地址，找到就直接返回；否则下一步。
2. 将请求发送给**本地DNS服务器**，在本地DNS服务器缓存中查询，如果查找到就直接返回，否则下一步；
3. 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会告诉本地DNS服务器去查询**哪个顶级域名服务器**。
4. 本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地DNS服务器，去查找**哪个权限域名服务器**。
5. 本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器请求域名所对应的IP地址。
6. 最后，本地域名服务器告诉主机**请求域名**所对应的IP地址。

比如要查询 [www.baidu.com](https://link.juejin.cn?target=http%3A%2F%2Fwww.baidu.com) 的 IP 地址:

- 首先会在浏览器的缓存中,是否查找到www.baidu.com的对应的IP，找到就直接返回；否则下一步。
- 将请求发送给本地DNS服务器，在本地DNS服务器缓存中查询，如果查找到就直接返回，否则下一步；
- 本地DNS服务器向**根域名服务器**发送请求，根域名服务器返回负责.com 的顶级域名服务器的IP地址的列表。
- 本地DNS服务器再向其中一个负责 **.com**的顶级域名服务器发送一个请求，返回负责 **.baidu**的权威域名服务器的IP地址列表。
- 本地DNS服务器再向其中一个权威域名服务器发送一个请求，返回www.baidu.com所对应的IP地址。

###  59. 在浏览器中输入www.baidu.com后执行的全部过程？

1. 域名解析（域名 [www.baidu.com ](http://www.baidu.com/)变为 ip 地址）。

   **浏览器搜索自己的DNS缓存**（维护一张域名与IP的对应表）；若没有，则搜索**操作系统的DNS缓存**（维护一张域名与IP的对应表）；若没有，则搜索操作系统的**hosts文件**（维护一张域名与IP的对应表）。

   若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即**本地 dns 服务器**（递归查询），**本地域名服务器查询自己的dns缓存**，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。

2. 发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 **80** 端口发起 tcp 的连接。

3. 建立 tcp 连接后发起 http 请求。

4. 服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。

5. 浏览器解析 html 代码，并请求 html 中的资源。

6. 浏览器对页面进行渲染，并呈现给用户。

附一张形象的图片：

<img src="images/image-20210525172545204.png" width="75%" />