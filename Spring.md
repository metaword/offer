## Spring

### 1 Spring IOC如何解决循环引用？

#### 1.1 三级缓存

SpringIOC 通过三级缓存来解决循环依赖问题，三级缓存指的是三个Map：

- singletonObjects：一级缓存，key为BeanName，value为Bean，日常获取Bean的地方

- earlySingletonObjects：二级缓存，key为BeanName，value为Bean，已经实例化但还没有进行属性注入的Bean，由三级缓存放入
- singletonFactories：三级缓存，key为BeanName，value为对象工厂（ObjectFactory）

在实际使用中，要获取一个bean，先从一级缓存一直查找到三级缓存，缓存bean的时候是从三级到一级的顺序保存，并且缓存bean的过程中，三个缓存都是互斥的，只会保持bean在一个缓存中，而且，最终都会在一级缓存中。

解决循环依赖

SpringIOC解决循环依赖的思路就是依靠缓存，同时还得引出个概念即早期暴露引用。我们知道在IOC容器里Bean的初始化的过程分为三个步骤：==创建实例、属性注入实例、回调实例实现的接口方法==。

解决思路就在这：当我们创建实例与属性注入实例这俩个步骤之间的时候，我们引入缓存，将这些已经创建好但是并没有注入属性的实例放到缓存里，而这些放在缓存里但是没有被注入属性的实例对象，就是解决循环依赖的方法。

打个比方：A对象的创建需要引用到B对象，而B对象的创建也需要A对象，而此时当B对象创建的时候直接从缓存里引用A对象（虽然不是完全体A对象，毕竟没有赋值处理），当B对象完成创建以后再被A对象引用进去，则A对象也完成了创建。

解决循环依赖具体过程

对Bean的创建最为核心三个方法解释如下：

- createBeanInstance：实例化，通过反射调用对象构造方法实例化对象；
- populateBean：填充属性，主要是对bean的依赖属性进行赋值；
- initializeBean：初始化，可以回调InitializingBean、initMethod等方法。

实例化A的时候，先将A创建（早期对象）放入一个池子（singletonFactories）中。这个时候虽然属性没有赋值，但是容器已经能认识这个是A对象，只是属性全是null而已。在populateBean方法中对属性赋值的时候，发现A依赖了B，那么就先去创建B，又走一遍bean的创建过程（创建B）。同样也会把B的早期对象放入缓存（singletonFactories）中。当B又走到 populateBean方法（负责填充Bean实例属性的方法）的时候，发现依赖了A，我们又去创建A，但是这个时候去创建A，发现我们在缓存（singletonFactories）能找到A（早期对象），此时会通过A的ObjectFactory获取A，并把A从三级缓存移到二级缓存。然后就可以把B的A属性赋值了，这个时候B就初始化完成了，初始化完成后就会把B从三级缓存移到一级缓存。完成B实例化后，回到A调用的populateBean方法中。返回的就是B对象了，对A的B属性进行赋值就可以了。

![在这里插入图片描述](images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NjYzNQ==,size_16,color_FFFFFF,t_70.png)

#### 1.2 IOC无法解决的两种循环依赖

- 一种是非单例对象，因为非单例对象不会放入缓存的。每次都是需要创建。
- 二是通过构造器注入，也无法解决。从上面的流程可以看出，调用构造器创建实例是在createBeanInstance方法，而解决循环依赖是在populateBean（负责属性注入的方法）这个方法中，执行顺序也决定了无法解决该种循环依赖。

#### 1.3 为什么采用三级缓存？

- 一级缓存是单例缓存池（singletonObjects）

- 二级缓存是早期对象（earlySingletonObjects）

- 三级缓存是一个包裹对象ObjectFactory（registeredSingletons），通过getObject获取到早期对象。

从上面的流程来看，实际上二级缓存已经可以解决循环依赖了，那么为什么Spring还要包裹出来一个三级缓存呢？

三级缓存其实是为了解决代理对象之间（AOP）的循环依赖。如果没有三级缓存，在对象被AOP代理的情况下，存入二级缓存前都需要先去做AOP代理。二级缓存存在的必要就是为了性能，从三级缓存的工厂创建出对象，直接放入二级缓存，避免每次都从工厂中获取。

通过第三级缓存我们可以拿到可能经过包装的对象，解决对象代理封装的问题。

三级缓存的value是ObjectFactory，ObjectFactory 的 getObject 如果包装的对象被AOP代理，则会返回相应的代理对象。

#### 1.4 三级缓存的划分及作用

一级缓存 singletonObjects 是完整的bean，它可以被外界任意使用，并且不会有歧义。

二级缓存 earlySingletonObjects 是不完整的bean，没有完成初始化，它与singletonObjects的分离主要是职责的分离以及边界划分，可以试想一个Map缓存里既有完整可使用的bean，也有不完整的，只能持有引用的bean，在复杂度很高的架构中，很容易出现歧义，并带来一些不可预知的错误。

三级缓存 singletonFactories ，其职责就是包装一个bean，有回调逻辑，主要用于解决代理对象的循环依赖，所以它的作用非常清晰，并且只能处于第三层。

在实际使用中，要获取一个bean，先从一级缓存一直查找到三级缓存，缓存bean的时候是从三级到一级的顺序保存，并且缓存bean的过程中，三个缓存都是互斥的，只会保持bean在一个缓存中，而且，最终都会在一级缓存中。

#### 1.5 总结

1. SpringIOC 通过三级缓存解决循环依赖
2. 要获取一个bean，先从一级缓存一直查找到三级缓存，缓存bean的时候是从三级到一级的顺序保存，并且缓存bean的过程中，三个缓存都是互斥的，只会保持bean在一个缓存中，而且，最终都会在一级缓存中。
3. Bean在实例化后（createBeanInstance）、属性注入前（populateBean），会先将属性为null的Bean包装成对象工厂（ObjectFactory）放入三级缓存中，在属性注入过程中会依次从一级到三级查询缓存查找依赖的Bean，不存在则先实例化依赖的Bean，完成属性注入。Bean初始化完成后，会被放入一级缓存。
4. 三级缓存其实是为了解决代理对象之间（AOP）的循环依赖，通过第三级缓存我们可以拿到可能经过包装的对象，解决对象代理封装的问题。



## 2 Spring中Bean的生命周期



![深究Spring中Bean的生命周期](images/java0-1558500658.jpg)

**Bean 的生命周期**

1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
2. Bean实例化后对将Bean的引入和值注入到Bean的属性中
3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法
4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。
6. 如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。
7. 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用
8. 如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。
9. 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
10. 如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。



## 3 IOC和DI

### 3.1 IOC是什么

**Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。**在Java开发中，**Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。**如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：

　　●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；**谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。**

　　●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？**因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。**

　　用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：

![img](images/261421378318292-20221028163550092.jpg)

 当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示：

![在这里插入图片描述](images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGVhLVNpcg==,size_12,color_FFFFFF,t_70,g_se,x_16.png)



### 3.2、IoC能做什么

　　IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出==松耦合、更优良的程序==。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。

　　其实**IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。**

　　**IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。**

### 3.3、IoC和DI

　　**DI—Dependency Injection，即“依赖注入”**：**组件之间依赖关系**由容器在运行期决定，形象的说，即**由容器动态的将某个依赖关系注入到组件之中**。**依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。**通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。

　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：

　　●谁依赖于谁：当然是**应用程序依赖于IoC容器**；

　　●为什么需要依赖：**应用程序需要IoC容器来提供对象需要的外部资源**；

　　●谁注入谁：很明显是**IoC容器注入应用程序某个对象，应用程序依赖的对象**；

　　●注入了什么：就是**注入某个对象所需要的外部资源（包括对象、资源、常量数据）**。

　　**IoC和DI**由什么**关系**呢？其实它们**是同一个概念的不同角度描述**，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。

　



