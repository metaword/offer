# 剑指offer

## 第一章 面试的流程

#### 1.3.2 技术面试环节

> 面试提示：
>
> 面试官除了希望应聘者的代码能够完成基本的功能，还会关注应聘者是否考虑了边界条件、特殊输入(如空指针、空字符串等)及错误处理。



## 第二章 面试需要的基础知识

### 2.2 编程语言

通常语言面试有3种类型：

1. 面试官直接询问应聘者对语言感念的理解
2. 面试官拿出事先准备好的代码，让应聘者分析代码的执行结果，这种题型选择的代码通常包含比较复杂的语言特性。
3. 要求应聘者写代码定义一个类型或者实现类型中的成员函数。

#### 面试题2:实现SIngleton模式

**1.单例模式的定义**

**单例模式**确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。

**2.单例模式的特点**

- 单例类只能有一个实例
- 单例类必须自己创建自己的唯一实例
- 单例类必须给所有其他对象提供这一实例

单例模式保证了全剧对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。

**3.线程安全问题**

一方面在获取单例的时候，要保证不能产生多个实例对象，后面会详细讲到五种实现方式；
另一方面，在使用单例对象的时候，要注意单例对象内的实例变量是会被多线程共享的，推荐使用无状态的对象，不会因为多个线程的交替调度而破坏自身状态导致线程安全问题，比如我们常用的VO，DTO等（局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题）。

**4.实现单例模式的八种方式**

4.1饿汉式(静态常量) ==可用==

优点：实现简单，在类装载的时候完成实例化，避免了线程同步问题

缺点：在类装载的时候实例化，没有达到Lazy Loading的效果，==如果从始至终从未使用过这个实例，会造成内存浪费==

```java
public class Singleton{
  private final static Singleton INSTANCE = new Singleton();
  private Singleton(){}
  
  public static SIngleton getInstance(){
    return INSTANCE;
  }
}

```

4.2饿汉式(静态代码块)==可用==

这种方式和上面的类似，只不过将类实例化的过程放在了静态代码块中，也是在类封装的时候就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。

```java
public class Singleton{
  private static Singleton instance;
  
  static{
    instance = new Singleton();
  }
  
  private Singleton(){}
  
  public static Singleton getInstance(){
    return instance;
  }
}
```

4.3懒汉式(线程不安全)==不可用==

这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。



```java
public class Singleton{
  private static Singleton singleton;
  
  private Singleton(){}
  
  public static Singleton getInstance(){
    if(singleton == null){
      singleton = new Singleton();
    }
    return singleton;
  }
}
```

4.4 懒汉式(线程安全，同步方法)==不推荐使用==

解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。
缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。

```java
public class Singleton{
  private static Singleton singleton;
  
  private Singleton(){}
  
  public static synchronized Singleton getInstance(){
    if(singleton == null){
      singleton = new Singleton();
    }
    return singleton;
  }
}
```

4.5懒汉式(线程安全，同步代码块)==不可用==
由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。

```java
public class Singleton{
  private static Singleton singleton;
  
  private Singleton(){}
  
  public static Singleton getInstance(){
    if(singleton == null){
      synchronized(Singleton.class){
        singleton = new Singleton();
      }
    }
    return singleton;
  }
}
```

4.6双重检查==推荐使用==

Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。
优点：线程安全；延迟加载；效率较高

```java
public class Singleton{
  
  private static volatile SIngleton singleton;
  
  private Singleton(){}
  
  public static Singleton getInstance(){
    if(singleton == null){
      synchronized(Singleton.class){
        if(singleton == null){
          singleton = new Singleton();
        }
      }
    }
    return singleton;
  }
}
```

4.7静态内部类==推荐使用==
这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。
类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
优点：避免了线程不安全，延迟加载，效率高。

```java
public class Singleton{
  private Singleton(){}
  
  private static class SingletonInstance{
    private static final Singleton INSTANCE = new Singleton();   
  }
  
  public static Singleton getInstance(){
    return SingletonInstance.INSTANCE;
  }
}
```

4.8枚举==推荐使用==
借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象

```java
public enum Singleton{
  INSTANCE;
  public void whatevermethod(){
    
  }
}
```



单例模式的优点
系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。

单例模式的缺点
当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。

单例模式的使用场景

• 需要频繁的进行创建和销毁的对象；

• 创建对象时耗时过多或耗费资源过多，但又经常用到的对象；

• 工具类对象；

• 频繁访问数据库或文件的对象。

#### 面试题3:数组中重复的数字

##### 题目1，找出数组中重复的数字

> 在一个长度为n的数组里的所有数字都在0～n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次，请找出数组中任意一个重复的数字，例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3.

`方法1`：排序

先把输入的数组排序，从排序的数组中找出重复的数字是一件很容易的事情，只需要从头到尾扫描排序后的数组就可以了。排序一个长度`n`的数组需要$O(nlogn)$的时间。

`方法2:`哈希表

从头到尾按顺序扫描数组的每个数字，没扫描到一个数字的时候，都可以用$O(1)$，的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入哈希表。如果哈希表里已经存在该数字，就找到了一个重复的数字。这个算法的时间复杂度是$O(n)$，但他提高时间效率是一个大小为$O(n)$的哈希表为代价。

`方法3:`

从头到位依次扫描这个数组中的每个数字。当扫描到下表为i的数字时，首先比较这个数字(m)是不是等于i。如果是，则接着扫描下一个数字；如果不是，则再拿它和第m个数字进行比较。如果它和第m个数字相等，就找到了一个重复的数字；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置，接下来重复这个比较、交换的过程，直到发现一个重复的数字。

```java
public Solution{
  public int findRepeatNumber(int[] nums){
    int i = 0;
    while(i<nums.length){
      if(nums[i] == i){
        i++;
        continue;
      }
      if(nums[nums[i]] == nums[i]){
        return nums[i];
      }
      int tmp = nums[i];
      nums[i]=nums[tmp];
      nums[tmp]=tmp;    
    }
    return -1; 
  }
}
```

##### 题目2，不修改数组找出重复的数字

> 在一个长度为n+1的数组里的所有数字都在1～n的范围内，所有数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组。

`方法1`，可以创建一个长度为n+1的辅助数组，然后逐一把原数组的数字复制到辅助数组，如果原数组中被复制的数字是m，则把它复制到辅助数组中下标为m的位置，该方案需要$O(n)$的辅助空间。

`方法2，`把从1～n的数字从中间的数字m分为两部分，前面一半为1～m，后面一半为m+1～n。如果1～m的数字的数目超过m，那么这一半的区间里一定包含重复的数字；否则，另一半m+1～n的区间里一定包含重复的数字。然后继续把包含重复数字的区间一分为二，直到找到一个重复数字。这个过程和二分查找算法类似，只是多了一步统计区间里数字的数目。空间复杂度$O(1)$，时间复杂度$O(n)$，以时间换空间。

```java
    public int findRepeatNumber(int[] nums) {

        if (nums.length <= 0) {
            return -1;
        }

        int start = 1;
        int end = nums.length - 1;

        while (end >= start) {
            int middle = ((end - start) >> 1) + start;
            int count = countRange(nums, nums.length, start, middle);

            if (end == start) {
                if (count > 1) {
                    return start;
                } else {
                    break;
                }
            }

            if (count > (middle - start + 1)) {
                end = middle;
            } else {
                start = middle + 1;
            }
        }
        return -1;
    }

    private int countRange(int[] nums, int length, int start, int end) {

        if (nums.length == 0) {
            return 0;
        }
        int count = 0;
        for (int i = 0; i < length; i++) {
            if (nums[i] >= start && nums[i] <= end) {
                ++count;
            }
        }
        return count;
    }
```

#### 面试题4:二维数组中的查找

> 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个证书，判断数组中是否含有该整数。给定 target = `5`，返回 `true`。给定 target = `20`，返回 `false`。
>
> [
>
>  [1,   4,  7, 11, 15],
>
> [2,   5,  8, 12, 19],
>
> [3,   6,  9, 16, 22],
>
> [10, 13, 14, 17, 24],
>
> [18, 21, 23, 26, 30]
>
> ]

#### 面试题5:替换空格

> 实现一个函数，把字符串中的每个空格替换成%20，例如输入“We are happy.”，则输出“We%20are%20happy.”





#### 面试题6:从尾到头打印链表

> 输入一个链表的头节点，从尾到头反过来打印出每个节点的值。

### 2.3.4 树

面试的时候提到的树，大部分是二叉树，所谓二叉树是树的一种特殊结构，在二叉树中每个节点最多只能有两个字节点，在二叉树中最重要的操作，是遍历，按照某一顺序访问树中的所有节点。通常有三种便利方式：

1. 前序遍历：先访问根节点，再访问左子树，最后访问右子树
2. 中序遍历：先访问左子树，再访问跟节点，最后访问右子树
3. 后序遍历：先访问左子节点，再访问右子节点，最后访问根节点

`宽度优先搜索`:先访问树的第一层节点，再访问树的第二层节点，直到访问到最下面一层节点。再同一层节点中，以从左到右的顺序依次访问。

二叉树有很多特例，==二叉搜索树==中，左子节点总是小于或等于跟节点，而右子节点总是大于或等于跟节点。可以在$O(logn)$的时间内根据数值在二叉搜索树中找到一个节点。

二叉树的另外两个特例是==堆==和==红黑树==。堆分为最大堆和最小堆，在最大堆中跟节点的值最大，在最小堆中根节点的值最小。==有许多需要快速找到最大值或最小值的问题都可以用堆来解决。==红黑树是把书中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。

#### 面试题7:重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中不含有重复数字，例如输入的前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,4,8,6}.





#### 面试题8:二叉树的下一个节点

> 给定一颗二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？书中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。



#### 面试题9:用两个栈实现队列

> 用两个栈实现一个队列，请实现它的两个函数appendTail和deleteHead，分别完成再队列尾部插入节点和在队列头部删除节点的功能。





### 2.4 算法和数据操作

通常排序和查找是面试时考察算法的重点，应重点掌握==二分法==、==归并排序==、==快速排序==，做到能随时正确、完整写出他们的代码。

如果面试题要求在二维数组(迷宫或棋盘)上搜索路径，可以尝试用==回溯法==。通常==回溯法==很适合用递归的代码实现。

如果面试题是求某个问题的最优解，并且该问题可以分为多个字问题，那么我们可以尝试用动态规划，再用自上而下的递归思路去分析动态规划问题的时候，会发现字问题之间存在重叠的更小的字问题，为了不必要的重复计算，用自下而上的循环代码来实现，也就是把字问题的最优解先计算出来并用数组保存下来，接下来基于字问题的解计算大问题的解。

如果我们告诉面试官动态规划的思路之后，面试官还在提醒说在分解字问题的时候是不是存在某个特殊的选择，如果采用这个特殊的选择将一定得到最优解，那么通常面试官这样的提醒意味着该面试题适用于贪婪算法。

位运算可以看成一类特殊的算法，它把数字表示成二进制之后堆0和1的操作。由于位运算的对象为二进制数字，所以不是很直观，但掌握它也不难，因为总共只有与、或、异或、左移、右移5种运算。



#### 2.4.1递归和循环

如果需要重复地多次计算相同的问题，则通常可以选择用递归或者循环两种不同的方法。

1. 递归是在一个函数的内部调用这个函数自身
2. 循环则通过设置计算的初始值及终止条件，在一个范围内重复运算。

递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：

- 每一次函数调用，都需要在内存栈种分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间
- 递归中有可能很多计算都是重复的，从而对性能带来很大的负面影响。递归的本质是把一个问题分解成两个或者多个问题，如果多个小问题存在相互重叠的部分，就会存在重复的计算。
- 除了效率之外，递归还有可能引起调用栈溢出，系统需要为每一次函数调用在内存栈种分配空间，而每个进程的栈的容量是有限的，当递归调用的层级太多时，就会超出栈的容量，从而导致调用栈溢出。

#### 面试题10:斐波那契数列

题目1:求斐波那契数列的第n项

> 写一个函数，输入n，求斐波那契数列(Fibonacci)的第n项。

题目2:青蛙跳台阶问题🐸

> 一只🐸一次可以跳上1级台阶，也可以跳上2级台阶，求该青蛙跳上一个n级台阶总共有多少种跳法。

相关问题：我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形，请问用8个2x1的小矩形无重叠覆盖一个2x8的大矩形，总共有多少种方法？



#### 2.4.2查找和排序

> 如果面试题是要求在排序的数组中查找一个数字或者统计某个数字出现的次数，那么我们可以尝试用二分查找法。



#### 面试题11:旋转数组的最小数字

> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小的元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1；



#### 2.4.3回溯法

回溯法可以看成是暴力法的升级版，它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项，就这样重复选择，直至达到最终的状态。

用回溯法解决的问题的所有选项可以形象地用树状结构便是。在某步有n个可能的状态，那么该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线，经过这些连接线到达该节点的n个子节点。树的叶节点对应着终结状态，如果在叶节点的状态满足题目的约束条件那么我们找到了一个可行的解决方案。

如果在叶节点的状态不满足约束条件，那么只好回溯到它的上一节点再尝试其他选项，如果上一个接待你所有可能的选项都已经试过，并且不能到达满足约束条件的终结状态，则再次回溯到上一个节点。如果所有节点的所有选项都已经尝试过仍然不能到达满足约束条件的终结状态，则该问题无解。

#### 面试题12:矩阵中的路径

> 设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在距正中间向左⬅️、右➡️、上⬆️、下⬇️移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。
>
> [a b t g
>
>  c f c s
>
>  j d e h]

#### 面试题13:机器人的运动范围

地上有一个m行n列的方格，一个机器人从坐标(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的 格子。例如，当k为18时，机器人能够进入方格(35,37)，以为3+5+3+7=18。但它不能进入方格(35,38)，因为3+5+3+8=19，请问该机器人能够到达多少个格子？

#### 2.4.4动态规划与贪婪算法

如果面试题是求一个问题的最优解，而且该问题能够分解成若干个字问题，并且字问题之间还有重叠的更小的字问题，就可以考虑用动态规划来解决这个问题。

我们在应用动态规划之前要分析能否把大问题分解成小问题，分解的每隔小问题也存在最优解。如果把小问题的最优解组合起来能够得到整个问题的最优解，那么就可以应用动态规划解决这个问题。

#### 2.4.5位运算

左移运算符`m<<n`表示把`m`左移`n`位的时候，最左边的`n`位将被丢弃，同时在最右边补上`n`个0.

右移运算符是`m>>n`表示把`m`右移`n`位，在右移n位的时候，最右边的`n`位将被丢弃。但在右移时处理最左边位的情形要稍微复杂。如果数字是个无符号数值，则用0填补最左边的`n`位，如果数字是一个有符号数，则用数字的符号填补最左边的`n`位。

#### 面试题15：二进制中1的个数

> 请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1，因此如果输入9，则该函数输出2。

==把一个整数减去1之后，再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1变成0.==
